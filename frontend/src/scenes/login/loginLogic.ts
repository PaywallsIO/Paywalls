import { kea, path, props } from 'kea'
import { forms } from 'kea-forms'
import { router, encodeParams } from 'kea-router'
import { notifications } from '@mantine/notifications'
import axios from 'axios'
import Cookies from 'js-cookie'
import appLogic from '../app/appLogic'

import type { loginLogicType } from './loginLogicType'

interface LoginForm {
  email: string
  password: string
}

const loginLogic = kea<loginLogicType>([
  path(['scenes', 'auth', 'loginLogicType']),
  forms(({ }) => ({
    authForm: {
      defaults: {
        email: '',
        password: '',
      } as LoginForm,
      errors: ({ email, password }: LoginForm) => ({
        email: email ? (/^\S+@\S+$/.test(email) ? null : 'Please enter a valid email') : 'Please enter an email',
        password: password.length <= 6 ? 'Password should include at least 6 characters' + password.length : null,
      }),
      submit: async ({ email, password }) => {
        console.log({ email, password })
        try {
          const response = await axios.post('/api/token', { email, password })

          const { access, refresh } = response.data
          Cookies.set('access_token', access, { secure: true, sameSite: 'strict' })
          Cookies.set('refresh_token', refresh, { secure: true, sameSite: 'strict' })

          appLogic.actions.setAuthRefreshToken(access, refresh)

          notifications.show({
            color: 'green',
            title: 'Welcome back!',
            message: 'Great to see you.',
            radius: 'md',
          })
        } catch (error) {
          notifications.show({
            color: 'red',
            title: 'Error',
            message: 'Could not login. Please try again',
            radius: 'md',
          })
        }
      },
    },
  })),
])

export function handleLoginRedirect(): void {
  let nextURL = '/'
  try {
    const nextPath = router.values.searchParams['next'] || '/'
    const url = new URL(nextPath.startsWith('/') ? location.origin + nextPath : nextPath)
    if (url.protocol === 'http:' || url.protocol === 'https:') {
      // Note that the hash MUST be handled client-side because /login?next= is generated by the server-side
      // `login_required()` decorator, and hash params never make it to the server
      nextURL = url.pathname + url.search + encodeParams(router.values.hashParams, '#')
    }
  } catch (e) {
    // do nothing
  }
  // A safe way to redirect to a user input URL. Calls history.replaceState() ensuring the URLs origin does not change
  router.actions.replace(nextURL)
}

export default loginLogic
